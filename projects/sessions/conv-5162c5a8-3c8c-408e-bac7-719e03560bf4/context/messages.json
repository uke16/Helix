[
  {
    "role": "user",
    "content": "### Task:\nSuggest 3-5 relevant follow-up questions or prompts that the user might naturally ask next in this conversation as a **user**, based on the chat history, to help continue or deepen the discussion.\n### Guidelines:\n- Write all follow-up questions from the user\u2019s point of view, directed to the assistant.\n- Make questions concise, clear, and directly related to the discussed topic(s).\n- Only suggest follow-ups that make sense given the chat content and do not repeat what was already covered.\n- If the conversation is very short or not specific, suggest more general (but relevant) follow-ups the user might ask.\n- Use the conversation's primary language; default to English if multilingual.\n- Response must be a JSON array of strings, no extra text or formatting.\n### Output:\nJSON format: { \"follow_ups\": [\"Question 1?\", \"Question 2?\", \"Question 3?\"] }\n### Chat History:\n<chat_history>\nUSER: Lies die ersten 3 ADRs im adr/ Verzeichnis und fasse sie kurz zusammen. Nimm dir Zeit.\nASSISTANT: [Starte Claude Code...]\n\n\n[Read] \n[Glob] \n[Read] ..\n\n---\n\nIch habe alle drei ADRs gelesen. Hier ist die Zusammenfassung:\n\n---\n\n## Zusammenfassung der ersten 3 ADRs\n\n### ADR-000: Vision & Architektur\n\n**Kernidee**: HELIX v4 nutzt Claude Code CLI als \"Agent Harness\" - kein eigenes SDK noetig.\n\n**Wichtigste Entscheidungen**:\n- Claude Code liest automatisch `CLAUDE.md` als Context\n- Datei-basierte Orchestrierung statt Event-Bus oder SDK\n- Kommunikation zwischen Phasen ausschliesslich ueber Dateien (spec.yaml, review.json)\n- 3-Ebenen Logging: Phase-Logs, Projekt-Logs, System-Logs\n- Workflow: Consultant \u2192 Developer \u2192 Reviewer \u2192 Documentation\n\n**Arbeitsteilung**:\n- **Claude Code macht**: Agent Loop, Tool Calling, Error Handling, ReAct/CoT\n- **HELIX macht**: Verzeichnisse vorbereiten, CLAUDE.md generieren, Quality Gates, Orchestrierung\n\n---\n\n### ADR-001: Template & Context System\n\n**Kernidee**: Jinja2-basierte Templates fuer verschiedene Rollen und Sprachen.\n\n**Struktur**:\n- `templates/` - Hierarchische Templates (consultant/, developer/, reviewer/, documentation/)\n- `skills/` - Wiederverwendbare Wissensdateien (languages/, tools/, domains/)\n- Templates erben von `_base.md` und spezialisieren durch Bloecke\n\n**Automatische Erkennung**:\n- Sprache wird aus Dateiendungen abgeleitet (.py \u2192 python, .go \u2192 go)\n- Rolle wird aus Dateimustern erkannt (Dockerfile \u2192 deploy)\n\n**Context-Preparation**: Skills werden als Symlinks in Phase-Verzeichnisse verlinkt.\n\n---\n\n### ADR-002: Quality Gate System\n\n**Kernidee**: Deterministische Python-Checks statt LLM-basierter Validierung.\n\n**Gates pro Phase**:\n| Gate | Nach Phase | Prueft |\n|------|------------|--------|\n| QG1 | Consultant | Spec vollstaendig? (Felder, Dateien definiert) |\n| QG2 | Developer | Dateien erstellt? Syntax OK? |\n| QG3 | Reviewer | Review approved? |\n| QG4 | Documentation | Doku geschrieben? |\n\n**Bei Failure**: Retry, Abort, oder Escalation Meeting (je nach Gate)\n\n**Vorteile**: Schnell, deterministisch, einfach testbar, keine API-Kosten.\n\n---\n\nDiese drei ADRs bilden zusammen das Fundament von HELIX v4: Eine klare Architektur (000), ein flexibles Template-System (001), und deterministische Qualitaetssicherung (002).\n\n<!-- STEP: done -->\n</chat_history>"
  }
]