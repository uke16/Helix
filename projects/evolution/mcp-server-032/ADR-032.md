---
adr_id: "032"
title: MCP Server für Hardware-Teststand-Orchestrierung
status: Integrated

project_type: external
component_type: SERVICE
classification: NEW
change_scope: major

files:
  create:
    - mcp/base/server.py
    - mcp/base/requirements.txt
    - mcp/hardware/server.py
    - mcp/hardware/locking.py
    - mcp/hardware/audit.py
    - mcp/hardware/config.yaml
  modify: []
  docs:
    - mcp/base/README.md
    - mcp/hardware/README.md
    - mcp/hardware/docs/JLINK_API.md

depends_on: []
---

# ADR-032: MCP Server für Hardware-Teststand-Orchestrierung

## Status
✅ Integrated

## Kontext

### Ziel
MCP Server für Hardware-Teststände (FPGA + J-Link) der funktioniert mit:
- Claude Desktop (lokal + remote)
- ChatGPT (remote only, Developer Mode)
- HELIX (als MCP Client)

### Problem: Protokoll-Kompatibilität

**Erfahrung zeigt:** MCP-Schema muss EXAKT stimmen, sonst Initialisierung fehlgeschlagen.

| Client | Transport | Besonderheiten |
|--------|-----------|----------------|
| Claude Desktop (lokal) | stdio | Funktioniert meist |
| Claude Desktop (remote) | SSE / Streamable HTTP | Benötigt bestimmte Plans |
| ChatGPT | SSE / Streamable HTTP | Remote only, Schema-sensitiv |

### Iterativer Ansatz

**Erwartung:** Mehrere Iterationen bis Kompatibilität erreicht.

```
Iteration 1: Dummy-Server → Test Claude Desktop (stdio)
Iteration 2: + SSE Transport → Test Claude Desktop (remote)
Iteration 3: + Schema-Anpassungen → Test ChatGPT
Iteration 4: Beide funktionieren → Hardware-Tools hinzufügen
Iteration N: Production-ready
```

## Entscheidung

### Zwei-Schichten-Architektur

```
┌─────────────────────────────────────────────────────────────────┐
│                    mcp/hardware/                                 │
│  Hardware-spezifische Tools (station_*, locking, audit)         │
└──────────────────────────┬──────────────────────────────────────┘
                           │ extends
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                    mcp/base/                                     │
│  Kompatible Basis (FastMCP, alle Transports, Dummy-Tools)       │
└─────────────────────────────────────────────────────────────────┘
```

### Technologie: FastMCP 2.0

```python
from fastmcp import FastMCP

mcp = FastMCP("helix-hardware")

@mcp.tool
def hello(name: str) -> str:
    return f"Hello, {name}!"

# Alle Transports:
mcp.run(transport="stdio")              # Claude Desktop lokal
mcp.run(transport="sse", port=8000)     # Legacy SSE
mcp.run(transport="http", port=8000)    # Streamable HTTP (recommended)
```

## Implementation

### Phase 0: Kompatible Basis (~2h)

**Ziel:** Dummy-Server der mit Claude UND ChatGPT funktioniert.

#### 0.1 Base Server

`mcp/base/server.py`:
```python
"""MCP Base Server - Compatible with Claude + ChatGPT."""
from fastmcp import FastMCP

mcp = FastMCP(
    name="helix-base",
    version="0.1.0",
)

@mcp.tool
def echo(message: str) -> str:
    """Echo a message back. Use this to test connectivity."""
    return f"Echo: {message}"

@mcp.tool  
def add(a: int, b: int) -> int:
    """Add two numbers. Use this to test tool execution."""
    return a + b

@mcp.tool
def server_info() -> dict:
    """Get server information."""
    return {
        "name": "helix-base",
        "version": "0.1.0",
        "transports": ["stdio", "sse", "http"],
        "status": "ready"
    }

if __name__ == "__main__":
    import sys
    transport = sys.argv[1] if len(sys.argv) > 1 else "stdio"
    
    if transport == "stdio":
        mcp.run(transport="stdio")
    elif transport == "sse":
        mcp.run(transport="sse", host="0.0.0.0", port=8000)
    elif transport == "http":
        mcp.run(transport="http", host="0.0.0.0", port=8000, path="/mcp")
```

`mcp/base/requirements.txt`:
```
fastmcp>=2.0.0
```

#### 0.2 Test-Matrix

| Test | Command | Erwartung |
|------|---------|-----------|
| Claude Desktop (stdio) | `python server.py stdio` | ✅ Iteration 1 |
| Claude Desktop (SSE) | `python server.py sse` + URL | ⚠️ Iteration 2-3 |
| ChatGPT (Streamable HTTP) | `python server.py http` + URL | ⚠️ Iteration 2-3 |
| MCP Inspector | `npx @modelcontextprotocol/inspector` | Debug |

#### 0.3 Iteration Log Template

```markdown
## Iteration Log

### Iteration 1 - YYYY-MM-DD
- **Transport:** stdio
- **Client:** Claude Desktop
- **Result:** ✅/❌
- **Error:** (if any)
- **Fix:** (what was changed)

### Iteration 2 - YYYY-MM-DD
- **Transport:** sse
- **Client:** Claude Desktop (remote)
- **Result:** ✅/❌
...
```

### Phase 1: Hardware-Tools (~3h)

**Nach Phase 0 Kompatibilität erreicht.**

#### 1.1 Server Structure

```
mcp/hardware/
├── server.py        # Extends base, adds hardware tools
├── locking.py       # Station locking
├── audit.py         # Audit logging
├── config.yaml      # Station configuration
└── docs/
    └── JLINK_API.md # API reference
```

#### 1.2 Hardware Server

`mcp/hardware/server.py`:
```python
"""MCP Hardware Server - Station control via FPGA + J-Link."""
from fastmcp import FastMCP
import httpx
import yaml
import time
from pathlib import Path

from locking import locker
from audit import audit

mcp = FastMCP(
    name="helix-hardware",
    version="0.1.0",
)

_config = None

def load_config():
    global _config
    if _config is None:
        with open(Path(__file__).parent / "config.yaml") as f:
            _config = yaml.safe_load(f)
    return _config

def get_station(name: str) -> dict:
    config = load_config()
    station = config["stations"].get(name)
    if not station:
        raise ValueError(f"Unknown station: {name}")
    return station

# === Lock Tools ===

@mcp.tool
def station_acquire(station: str, session_id: str, timeout: int = 300) -> str:
    """Acquire exclusive access to a station."""
    if locker.acquire(station, session_id, timeout):
        audit.log(station, "acquire", session_id, "success", 0)
        return f"Lock acquired on {station} for {timeout}s"
    lock = locker.is_locked(station)
    return f"Station {station} locked by {lock.session_id}"

@mcp.tool
def station_release(station: str, session_id: str) -> str:
    """Release exclusive access to a station."""
    if locker.release(station, session_id):
        audit.log(station, "release", session_id, "success", 0)
        return f"Lock released on {station}"
    return "Cannot release - locked by different session"

# === Station Tools ===

@mcp.tool
def list_stations() -> str:
    """List all available hardware test stations."""
    config = load_config()
    lines = ["Available stations:"]
    for name, station in config["stations"].items():
        fpga = station.get("fpga", {})
        lock = locker.is_locked(name)
        lock_status = f" [LOCKED by {lock.session_id}]" if lock else ""
        lines.append(f"  {name}: {station.get('description', '')}{lock_status}")
    return "\n".join(lines)

@mcp.tool
async def station_connect(station: str) -> str:
    """Connect to a station's debug target."""
    start = time.time()
    cfg = get_station(station)
    fpga = cfg["fpga"]
    
    try:
        async with httpx.AsyncClient(timeout=30) as client:
            r = await client.post(f"http://{fpga['host']}:{fpga['port']}/jlink/connect")
            data = r.json()
    except httpx.TimeoutException:
        return f"Timeout connecting to {station}"
    except httpx.ConnectError:
        return f"Cannot reach {station} - check network/VPN"
    
    duration = int((time.time() - start) * 1000)
    if "Cortex-M33 identified" in data.get("stdout", ""):
        audit.log(station, "connect", "unknown", "success", duration)
        return f"Connected to {station}"
    elif "0xFFFFFFFF" in data.get("stdout", ""):
        return f"Target locked. Use station_recover to power-cycle."
    return f"Connection failed: {data.get('stdout', '')[-300:]}"

@mcp.tool
async def station_recover(station: str) -> str:
    """Recover station from error state (power-cycles target)."""
    cfg = get_station(station)
    fpga = cfg["fpga"]
    voltage = fpga["voltage"]
    
    try:
        async with httpx.AsyncClient(timeout=30) as client:
            await client.post(
                f"http://{fpga['host']}:{fpga['port']}/jlink/power",
                json={"action": "cycle", "voltage": voltage}
            )
            import asyncio
            await asyncio.sleep(0.5)
            r = await client.post(f"http://{fpga['host']}:{fpga['port']}/jlink/connect")
            data = r.json()
    except Exception as e:
        return f"Recovery failed: {e}"
    
    if "Cortex-M33 identified" in data.get("stdout", ""):
        return f"Recovery successful! {station} reconnected."
    return "Recovery failed - target not responding"

@mcp.tool
async def station_registers(station: str) -> str:
    """Read CPU registers from station's target."""
    cfg = get_station(station)
    fpga = cfg["fpga"]
    try:
        async with httpx.AsyncClient(timeout=30) as client:
            r = await client.get(f"http://{fpga['host']}:{fpga['port']}/jlink/registers")
            data = r.json()
    except Exception as e:
        return f"Error: {e}"
    
    if not data.get("success"):
        return f"Failed: {data.get('error')}"
    regs = data.get("registers", {})
    lines = [f"Registers on {station}:"]
    for name in ["PC", "SP", "LR", "R0", "R1", "R2", "R3"]:
        if name in regs:
            lines.append(f"  {name}: 0x{regs[name]:08X}")
    return "\n".join(lines)

# Additional tools: station_flash, station_memory_read, station_halt, station_go, station_reset
# (siehe bestehende Implementation in mcp/hardware/)

if __name__ == "__main__":
    import sys
    transport = sys.argv[1] if len(sys.argv) > 1 else "stdio"
    
    if transport == "stdio":
        mcp.run(transport="stdio")
    elif transport == "sse":
        mcp.run(transport="sse", host="0.0.0.0", port=8000)
    elif transport == "http":
        mcp.run(transport="http", host="0.0.0.0", port=8000, path="/mcp")
```

### Phase 2: Remote Deployment

```
┌─────────────────┐     VPN/SSH Tunnel      ┌─────────────────┐
│  Claude/ChatGPT │◄──────────────────────►│  MCP Server     │
│  (Internet)     │     Port 8000           │  (Hetzner)      │
└─────────────────┘                         └────────┬────────┘
                                                     │ HTTP
                                                     ▼
                                            ┌─────────────────┐
                                            │  FPGA Boards    │
                                            │  (Local LAN)    │
                                            └─────────────────┘
```

**Optionen:**
- ngrok / Cloudflare Tunnel (schnell, public)
- SSH Port Forwarding (sicher, privat)
- VPN + direkter Zugriff (Produktion)

## Akzeptanzkriterien

### Phase 0: Basis-Kompatibilität
- [ ] Dummy-Server läuft (stdio)
- [ ] Claude Desktop (lokal) kann Tools aufrufen
- [ ] Claude Desktop (remote/SSE) kann Tools aufrufen
- [ ] ChatGPT (Developer Mode) kann Tools aufrufen
- [ ] Iteration Log dokumentiert alle Versuche

### Phase 1: Hardware-Tools
- [ ] list_stations zeigt Stationen
- [ ] station_acquire/release funktionieren
- [ ] station_connect mit Error-Handling
- [ ] station_recover mit Power-Cycle
- [ ] Audit-Logging aktiv

### Phase 2: Remote
- [ ] Server über Internet erreichbar
- [ ] Authentifizierung konfiguriert
- [ ] HTTPS/TLS aktiv

## Konsequenzen

### Positiv
- Eine Codebasis für alle Clients
- Iterativer Ansatz dokumentiert Learnings
- FastMCP reduziert Boilerplate

### Negativ
- Initiale Kompatibilitäts-Iterationen kosten Zeit
- Remote-Deployment adds Komplexität

### Risiken

| Risiko | Mitigation |
|--------|------------|
| Schema-Inkompatibilität | MCP Inspector zum Debuggen |
| ChatGPT ändert Requirements | Iteration Log, schnelle Anpassung |
| Transport-Bugs | FastMCP Community Support |

## Referenzen

- [FastMCP GitHub](https://github.com/jlowin/fastmcp)
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)
- [ChatGPT MCP Docs](https://platform.openai.com/docs/mcp)
- [J-Link API](mcp/hardware/docs/JLINK_API.md)
- [Services Layer Draft](drafts/DRAFT-helix-services-layer.md)
