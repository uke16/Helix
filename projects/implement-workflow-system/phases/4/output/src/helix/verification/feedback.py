"""Feedback delivery to running Claude sessions.

Provides mechanisms to send correction feedback to
running Claude Code sessions for self-correction.

The feedback is delivered via a file that the session monitors.
This allows the verification loop to communicate issues back
to the executing agent without interrupting the process.

Example:
    channel = FeedbackChannel(Path("phases/2"))
    await channel.send("Missing test file", attempt=1)

    # Later, after successful verification
    channel.clear()
"""

from pathlib import Path
from datetime import datetime
from typing import Optional


class FeedbackChannel:
    """Delivers feedback to running Claude Code sessions.

    Feedback is delivered via a file that the session monitors.
    The session's CLAUDE.md includes instructions to check for
    feedback files periodically.

    Attributes:
        session_dir: Directory where the session runs.
        feedback_path: Path to the feedback file.
    """

    FEEDBACK_FILE = "feedback.md"

    def __init__(self, session_dir: Path):
        """Initialize feedback channel.

        Args:
            session_dir: Directory where the session runs.
        """
        self.session_dir = Path(session_dir)
        self.feedback_path = self.session_dir / self.FEEDBACK_FILE

    async def send(
        self,
        message: str,
        attempt: int,
        errors: Optional[list[str]] = None,
    ) -> bool:
        """Send feedback message to session.

        Creates a feedback.md file that the running session
        should monitor and respond to.

        Args:
            message: Feedback message with correction instructions.
            attempt: Current attempt number (1-3).
            errors: Optional list of specific errors.

        Returns:
            True if feedback was delivered successfully.
        """
        error_list = ""
        if errors:
            error_list = "\n".join(f"- {e}" for e in errors)

        feedback_content = f'''# Verification Feedback

**Attempt**: {attempt}/3
**Time**: {datetime.now().isoformat()}
**Status**: NEEDS CORRECTION

---

## Issues Found

{message}

{f"### Specific Errors{chr(10)}{chr(10)}{error_list}" if error_list else ""}

---

## Required Actions

Please fix the issues listed above and update your output files.
After fixing, the verification will run again automatically.

**Important**: Do not delete this file - it will be cleared after successful verification.

---

*This feedback was generated by the Sub-Agent Verifier (ADR-025)*
'''

        try:
            self.feedback_path.write_text(feedback_content)
            return True
        except Exception:
            return False

    def clear(self) -> None:
        """Clear feedback file after successful verification.

        Should be called after verification passes to remove
        the feedback file and indicate success.
        """
        if self.feedback_path.exists():
            self.feedback_path.unlink()

    def has_pending_feedback(self) -> bool:
        """Check if there is pending feedback.

        Returns:
            True if feedback.md exists and contains pending feedback.
        """
        return self.feedback_path.exists()

    def read_feedback(self) -> Optional[str]:
        """Read current feedback content.

        Returns:
            Feedback content if exists, None otherwise.
        """
        if self.feedback_path.exists():
            return self.feedback_path.read_text()
        return None

    def get_attempt_number(self) -> int:
        """Extract attempt number from existing feedback.

        Parses the feedback file to determine which attempt
        we're currently on.

        Returns:
            Current attempt number (1-3), or 0 if no feedback.
        """
        if not self.feedback_path.exists():
            return 0

        try:
            content = self.feedback_path.read_text()
            # Look for "**Attempt**: N/3"
            for line in content.split("\n"):
                if "**Attempt**:" in line:
                    parts = line.split(":")
                    if len(parts) >= 2:
                        attempt_str = parts[1].strip().split("/")[0]
                        return int(attempt_str)
        except (ValueError, IndexError):
            pass

        return 0


class EscalationHandler:
    """Handles escalation to Consultant after final verification failure.

    When all retry attempts are exhausted, this handler creates
    an escalation report for the Consultant to review.
    """

    ESCALATION_FILE = "escalation.md"

    def __init__(self, project_dir: Path):
        """Initialize escalation handler.

        Args:
            project_dir: Project root directory.
        """
        self.project_dir = Path(project_dir)
        self.escalation_path = self.project_dir / self.ESCALATION_FILE

    async def escalate(
        self,
        phase_id: str,
        errors: list[str],
        attempts: int,
    ) -> bool:
        """Create escalation report for Consultant.

        Args:
            phase_id: ID of the failed phase.
            errors: List of error messages.
            attempts: Number of attempts made.

        Returns:
            True if escalation report was created.
        """
        error_list = "\n".join(f"- {e}" for e in errors)

        content = f'''# Escalation Report

**Phase**: {phase_id}
**Time**: {datetime.now().isoformat()}
**Attempts**: {attempts}
**Status**: FAILED - NEEDS CONSULTANT REVIEW

---

## Summary

Phase {phase_id} failed verification after {attempts} attempts.
Manual intervention is required.

## Errors

{error_list}

---

## Recommended Actions

1. Review the phase output in `phases/{phase_id}/output/`
2. Check the feedback history in `phases/{phase_id}/feedback.md`
3. Either:
   - Fix issues manually and re-run verification
   - Adjust the quality gate criteria if too strict
   - Skip this phase if non-critical

## To Resume

After fixing, run:
```bash
curl -X POST http://localhost:8001/helix/execute \\
  -d '{{"project_path": "...", "phase_filter": "{phase_id}", "reset": true}}'
```

---

*Escalation generated by Sub-Agent Verifier (ADR-025)*
'''

        try:
            self.escalation_path.write_text(content)
            return True
        except Exception:
            return False

    def has_escalation(self) -> bool:
        """Check if there is a pending escalation."""
        return self.escalation_path.exists()

    def clear_escalation(self) -> None:
        """Clear escalation after resolution."""
        if self.escalation_path.exists():
            self.escalation_path.unlink()
