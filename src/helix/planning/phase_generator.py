"""Phase Generator for dynamic project phases.

Generates phases.yaml and CLAUDE.md files from a ProjectPlan.

Example:
    generator = PhaseGenerator()
    phases_path = generator.generate_phases_yaml(plan, project_dir)
    claude_paths = generator.generate_phase_claudes(plan, project_dir)
"""

from pathlib import Path
from typing import Any
import yaml

from .agent import ProjectPlan, PlannedPhase


class PhaseGenerator:
    """Generates phase files from a ProjectPlan.

    Creates the phases.yaml file and individual CLAUDE.md
    files for each dynamic phase based on the plan.

    Attributes:
        base_workflow: Base workflow template to extend.
    """

    CLAUDE_MD_TEMPLATE = '''# Phase {phase_num}: {name}

> {description}

---

## Context

This phase is part of a dynamically generated workflow.
Read the project ADR for full context.

## Dependencies

{dependencies}

## Tasks

1. Read the project ADR and understand requirements
2. Implement the functionality described above
3. Write tests for your implementation
4. Document your changes

## Output

Write all output files to `output/` in this phase directory:
- Source files: `output/src/...`
- Tests: `output/tests/...`
- Documentation: `output/docs/...`

## Quality Gate

Your output will be verified by a sub-agent (ADR-025).
Ensure:
- All expected files exist
- Code has valid syntax
- Tests are included

## Estimated Effort

This phase is estimated to require {estimated_sessions} Claude Code session(s).

---

*Generated by PlanningAgent (ADR-026)*
'''

    PHASES_YAML_HEADER = '''# Dynamically Generated Phases
# Created by PlanningAgent (ADR-026)
#
# This file was automatically generated based on project analysis.
# Modify with care - changes may be overwritten.

'''

    def __init__(self, base_workflow: str = "intern-complex"):
        """Initialize the Phase Generator.

        Args:
            base_workflow: Base workflow template name.
        """
        self.base_workflow = base_workflow

    def generate_phases_yaml(
        self,
        plan: ProjectPlan,
        project_dir: Path,
    ) -> Path:
        """Generate phases.yaml from ProjectPlan.

        Creates a phases.yaml file with:
        1. Optional feasibility phase
        2. Dynamic development phases
        3. Standard closing phases (verify, documentation)

        Args:
            plan: ProjectPlan from PlanningAgent.
            project_dir: Project directory path.

        Returns:
            Path to generated phases.yaml.
        """
        project_dir = Path(project_dir)
        project_dir.mkdir(parents=True, exist_ok=True)

        phases_data: dict[str, Any] = {
            "project": {
                "name": project_dir.name,
                "type": "complex",
                "generated": True,
                "max_retries": 3,
            },
            "phases": [],
        }

        phase_num = 1

        # Optional feasibility phase
        if plan.feasibility_needed:
            phases_data["phases"].append({
                "id": "feasibility",
                "name": "Feasibility Study",
                "type": "research",
                "description": "Analyze scope, identify risks, validate approach",
                "template": "consultant/feasibility.md",
                "verify_agent": True,
                "optional": True,
                "output": [
                    "feasibility-report.md",
                ],
            })
            phase_num += 1

        # Dynamic development phases
        for phase in plan.phases:
            phases_data["phases"].append({
                "id": phase.id,
                "name": phase.name,
                "type": phase.type,
                "description": phase.description,
                "estimated_sessions": phase.estimated_sessions,
                "depends_on": phase.dependencies if phase.dependencies else None,
                "verify_agent": True,
                "output": [
                    f"src/**/*.py",
                    f"tests/**/*.py",
                ],
            })
            phase_num += 1

        # Standard closing phases
        phases_data["phases"].extend([
            {
                "id": "verify",
                "name": "Verification",
                "type": "test",
                "description": "Run all tests and verify implementation",
                "template": "testing/comprehensive.md",
                "verify_agent": True,
                "after_dynamic": True,
                "quality_gate": {
                    "type": "tests_pass",
                },
            },
            {
                "id": "documentation",
                "name": "Documentation",
                "type": "documentation",
                "description": "Update project documentation",
                "template": "documentation/technical.md",
                "verify_agent": False,
                "after_dynamic": True,
                "output": [
                    "docs/**/*.md",
                    "README.md",
                ],
            },
        ])

        # Write phases.yaml
        output_path = project_dir / "phases.yaml"
        content = self.PHASES_YAML_HEADER + yaml.dump(
            phases_data,
            default_flow_style=False,
            sort_keys=False,
            allow_unicode=True,
        )
        output_path.write_text(content)

        return output_path

    def generate_phase_claudes(
        self,
        plan: ProjectPlan,
        project_dir: Path,
    ) -> list[Path]:
        """Generate CLAUDE.md for each dynamic phase.

        Creates a CLAUDE.md file in each phase directory
        with specific instructions for that phase.

        Args:
            plan: ProjectPlan from PlanningAgent.
            project_dir: Project directory path.

        Returns:
            List of paths to generated CLAUDE.md files.
        """
        project_dir = Path(project_dir)
        created: list[Path] = []
        phase_num = 1

        # Feasibility phase if needed
        if plan.feasibility_needed:
            phase_dir = project_dir / "phases" / str(phase_num)
            phase_dir.mkdir(parents=True, exist_ok=True)
            (phase_dir / "output").mkdir(exist_ok=True)

            claude_path = self._write_claude_md(
                phase_dir=phase_dir,
                phase_num=phase_num,
                name="Feasibility Study",
                description="Analyze the project scope, identify technical risks, and validate the proposed approach.",
                dependencies=[],
                estimated_sessions=1,
            )
            created.append(claude_path)
            phase_num += 1

        # Dynamic development phases
        for phase in plan.phases:
            phase_dir = project_dir / "phases" / str(phase_num)
            phase_dir.mkdir(parents=True, exist_ok=True)
            (phase_dir / "output").mkdir(exist_ok=True)

            claude_path = self._write_claude_md(
                phase_dir=phase_dir,
                phase_num=phase_num,
                name=phase.name,
                description=phase.description,
                dependencies=phase.dependencies,
                estimated_sessions=phase.estimated_sessions,
            )
            created.append(claude_path)
            phase_num += 1

        return created

    def _write_claude_md(
        self,
        phase_dir: Path,
        phase_num: int,
        name: str,
        description: str,
        dependencies: list[str],
        estimated_sessions: int,
    ) -> Path:
        """Write a CLAUDE.md file for a phase.

        Args:
            phase_dir: Phase directory path.
            phase_num: Phase number.
            name: Phase name.
            description: Phase description.
            dependencies: List of dependency phase IDs.
            estimated_sessions: Estimated sessions.

        Returns:
            Path to the written CLAUDE.md file.
        """
        if dependencies:
            deps_text = "This phase depends on:\n" + "\n".join(
                f"- Phase `{dep}`" for dep in dependencies
            )
        else:
            deps_text = "This phase has no dependencies."

        content = self.CLAUDE_MD_TEMPLATE.format(
            phase_num=phase_num,
            name=name,
            description=description,
            dependencies=deps_text,
            estimated_sessions=estimated_sessions,
        )

        claude_path = phase_dir / "CLAUDE.md"
        claude_path.write_text(content)
        return claude_path

    def generate_decomposed_yaml(
        self,
        plan: ProjectPlan,
        project_dir: Path,
    ) -> Path:
        """Generate decomposed-phases.yaml with details.

        Creates a detailed breakdown file showing the
        planning agent's analysis and phase decomposition.

        Args:
            plan: ProjectPlan from PlanningAgent.
            project_dir: Project directory path.

        Returns:
            Path to decomposed-phases.yaml.
        """
        project_dir = Path(project_dir)

        data = {
            "generated_by": "PlanningAgent (ADR-026)",
            "feasibility_needed": plan.feasibility_needed,
            "reasoning": plan.reasoning,
            "total_estimated_sessions": plan.total_estimated_sessions,
            "phases": [
                {
                    "id": p.id,
                    "name": p.name,
                    "type": p.type,
                    "description": p.description,
                    "estimated_sessions": p.estimated_sessions,
                    "dependencies": p.dependencies,
                }
                for p in plan.phases
            ],
        }

        output_path = project_dir / "decomposed-phases.yaml"
        output_path.write_text(yaml.dump(data, default_flow_style=False))
        return output_path
