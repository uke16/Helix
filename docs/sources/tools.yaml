# docs/sources/tools.yaml
# PRIMARY SOURCE for Tool Documentation in HELIX v4
#
# This file defines all available tools for Claude Code instances.
# All documentation is generated from this file.
#
# Regenerate docs: python -m helix.tools.docs_compiler compile

_meta:
  version: "1.0"
  description: "Tool Definitions for HELIX v4"
  generated_outputs:
    - CLAUDE.md
    - skills/helix/SKILL.md

tools:
  - id: adr_tool
    name: "ADR Tool"
    module: "helix.tools.adr_tool"
    description: "Validate and finalize Architecture Decision Records"

    cli_commands:
      - command: "python -m helix.tools.adr_tool validate path/to/ADR.md"
        description: "Validate an ADR"
      - command: "python -m helix.tools.adr_tool finalize path/to/ADR.md"
        description: "Finalize (move to adr/ and update INDEX)"
      - command: "python -m helix.tools.adr_tool next-number"
        description: "Get next available ADR number"

    python_api:
      imports: |
        from helix.tools import validate_adr, finalize_adr, get_next_adr_number

      examples:
        - name: "Validate"
          code: |
            result = validate_adr("ADR-feature.md")
            if not result.success:
                print(result.errors)

        - name: "Finalize"
          code: |
            result = finalize_adr("ADR-feature.md")
            print(result.final_path)  # → adr/013-feature.md

        - name: "Next number"
          code: |
            next_num = get_next_adr_number()  # → 13

    see_also:
      - docs/ADR-TEMPLATE.md
      - skills/helix/adr/SKILL.md

  - id: docs_compiler
    name: "Docs Compiler"
    module: "helix.tools.docs_compiler"
    description: "Compile documentation from YAML sources and Jinja2 templates"

    cli_commands:
      - command: "python -m helix.tools.docs_compiler compile"
        description: "Generate docs"
      - command: "python -m helix.tools.docs_compiler validate"
        description: "Check without writing"
      - command: "python -m helix.tools.docs_compiler sources"
        description: "List sources"
      - command: "python -m helix.tools.docs_compiler diff"
        description: "Show changes"

    python_api:
      imports: |
        from helix.tools.docs_compiler import DocsCompiler

      examples:
        - name: "Compile"
          code: |
            compiler = DocsCompiler()
            result = compiler.compile()
            print(f"Generated: {result.files}")

        - name: "Validate"
          code: |
            compiler = DocsCompiler()
            issues = compiler.validate()
            if issues:
                print(issues)

    sources_location: "docs/sources/*.yaml"
    templates_location: "docs/templates/*.j2"

    see_also:
      - docs/SELF-DOCUMENTATION.md

  - id: verify_phase
    name: "Verify Phase Tool"
    module: "helix.tools.verify_phase"
    description: "Verify phase outputs before completing a phase"

    cli_commands:
      - command: "python -m helix.tools.verify_phase"
        description: "Verify current phase outputs"

    checks:
      - "All expected files exist"
      - "Python files have valid syntax"
      - "YAML files are parseable"
      - "Markdown has valid structure"

    usage_context: "Called automatically by orchestrator, can also be run manually"

  - id: debug_tools
    name: "Debug & Observability Tools"
    module: "helix.debug"
    description: "Live debugging and cost tracking for Claude CLI executions"

    cli_commands:
      - command: "./control/claude-wrapper.sh -v -- --print 'prompt'"
        description: "Run Claude CLI with verbose debug output"
      - command: "./control/helix-debug.sh -d phases/01-analysis"
        description: "Start debug session with terminal dashboard"
      - command: "./control/helix-debug.sh -w -p 8080 phases/01-analysis"
        description: "Start debug session with web dashboard"

    python_api:
      imports: |
        from helix.debug import StreamParser, ToolTracker, CostCalculator, LiveDashboard

      examples:
        - name: "Parse Claude CLI stream"
          code: |
            parser = StreamParser()
            async for event in parser.parse_stream(process.stdout):
                print(f"{event.type}: {event.data}")

        - name: "Track tool calls"
          code: |
            tracker = ToolTracker()
            tracker.start_tool("123", "bash_tool", {"command": "ls"})
            tracker.end_tool("123", output="file.txt", success=True)
            print(tracker.get_stats())

        - name: "Calculate costs"
          code: |
            calc = CostCalculator()
            calc.add_usage(1000, 500, model="claude-sonnet")
            print(f"Cost: ${calc.get_total_cost():.4f}")

  - id: orchestrator_cli
    name: "Project Orchestrator CLI"
    module: "helix.cli.main"
    description: "Autonomous project execution commands"

    cli_commands:
      - command: "helix new my-feature --type simple"
        description: "Create new project with standard structure"
      - command: "helix run projects/my-feature"
        description: "Execute all phases autonomously"
      - command: "helix run projects/my-feature --resume"
        description: "Resume after failure"
      - command: "helix run projects/my-feature --dry-run"
        description: "Show execution plan without running"
      - command: "helix status projects/my-feature"
        description: "Show current project status"
      - command: "helix list"  # NOTE: Not implemented yet
        description: "List all projects"

    python_api:
      imports: |
        from helix.orchestrator import OrchestratorRunner, StatusTracker, PhaseExecutor

      examples:
        - name: "Run project programmatically"
          code: |
            runner = OrchestratorRunner(project_dir=Path("projects/my-feature"))
            success = await runner.run()
            if not success:
                print(f"Failed at: {runner.get_status().current_phase}")

        - name: "Check project status"
          code: |
            tracker = StatusTracker(Path("projects/my-feature"))
            tracker.load()
            for phase_id, status in tracker.phases.items():
                print(f"{phase_id}: {status.state}")
